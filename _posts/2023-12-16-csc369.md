---
title: "CSC369 Review"
date: 2023-12-16
---

# L12

## Non-deadlock bugs

- Atomicity violation bugs (`++` and `--`)
- Order violation bugs (wrong order assumptions)

## Deadlocks

Mutal blocking of a set of threads.

- Communication deadlocks
- Resource deadlocks

### Deadlock prevention

#### Necessary conditions

1. Mutal exclusion

Only one process may use a resource at a time.

Prevention: use lock-free operations
```c
int CAS(int *addr, int expected, int new);

void AtomicAdd(int *val, int a) {
    do {
        int old = *val;
    } while (CAS(val, old, old + a) == 0);
}
```


2. Hold-and-wait

A process may hold allocated resource while awaiting assignment of others.

Prevention:
- Either process gets all resource, or none of them. (Long wait, might not know
resources a priori.)
- `trylock()` (Might result in livelock.)

3. No preemption

No resource can be forcibly removed from a process holding it.

Prevention:

Allow forcibly remove of resource, might require rollback

#### Sufficient conditions

4. Circular wait

A closed chain of processes exists, such that each process holds
some resources needed by the next process.

Prevention:

Ensure total / partial order

### Deadlock avoidance

Allows first three conditions, but ensures circular wait cannot occur.

1. Do not start a process if total resources required exceeds resources available.
2. Do not grant individual resource request if future paths results in deadlock.

#### Restrictions

1. Maximum resource requirements must be known a priori.
2. Process must be independent.
3. There must be a fixed number of resources.

#### Banker's algorithm

Each thread states its maximum resource requirements, acquires and releases
resources incrementally.

Runtime system delays granting some requests to ensure the system never deadlocks.

For every request:

1. Check if the resource can be granted.
2. Assume request is granted, check if the new state is safe.

A state is safe if there exists some sequence which every request is
successful.

### Deadlock detection

Trigger:

1. On every allocation request
2. Fixed period
3. System utilization drops below a threshold

Using a resource allocation graph:

- Nodes are processes and resources
- Arcs from resource to process represent allocations
- Arcs from process to resource represent ungranted requests

Note: not valid when there are multiple instances of same resource.

### Deadlock recovery

- Kill all deadlocked processes
- Back up and restart
- Selectively kill process
- Selectively preempt 

#### Ostrich Algorithm

Ignore the problem and hope that it doesn't happen often.

- Modern O/S virtualizes physical resources.
- Only dead lock on logical resources.

### Communication deadlocks

Example: packet loss

Solution: timeout, resend, protocol

## Transaction and Atomicity

### Transaction

A collection of operations that performs a single logical function.

Either commit (successful, cannot be undone), or abort (rollbacked).

Logs are time-consuming and large. Use checkpoints instead.

### Concurrent tranactions

- All transactions are protected with a mutex.
- Allow overlap operations, as long as they don't conflict.

Conflict if writes to the same data. Order does not matter.

#### Two-phase locking

Each data has their own locks.

Each transaction has growing (acquire only) and shrinking (release only) phase.

Use abort and retry if any lock is unavailable.

#### Timestamp

Each transaction gets unique timestamp, and each data has two timestamp:

- Largest timestamp of transactions that reads.
- Largest timestamp of transactions that writes.

Read: if tranaction's timestamp is earlier than last write, then needs to restart.

Write: if transaction's timestamp is earlier than last access, then needs to restart.

# L11

## Redundancy

### RAID

Redundant array of independent disks.

- RAID0: Striping
- RAID1: Mirror each disk
- RAID5: Store pairity on one additional disk

## FFS

Files laid out with spatial locality in mind. Read performs well,
writes are not well-clustered.

But reads are cached in memory.

## LFS

Treat storage as a circular log.

- Write throughput improved.
- Cache recovery is simpler.

Inodes are scattered over all the disk.

Inode map to find inodes. FS must have some fixed and known location on disk
to begin lookup.

TODO:

- Crash recovery
- Garbage collection

## VFS Concept

Abstraction of file and collections, seperate from implementations.

```
read <-> sys_read <-> vfs_read <-> [file system]_read
```

## SSD

Page: unit of read/program (write).

Block: unit of earse.

Multiple channels so data can be striped across blocks (like RAID5).

Wear leveling:
- Always write to new location
- Map logical FS block to physical block
- Old versions are marked stale

Garbage collection:
- Reclaim stale pages by erase.

### Flash Translation Layer

- Translate logical blocks into physical blocks.
- Reduce extra copying to deal with erases.
- Implement wear leveling.

## FS goals

- Translate file name info number
- Sequential and random access
- Small/large files
- Metadata
- Crash recovery
- Free space
- Locality

## Modern file systems

ZFS: Pooled storage, integrity, performance.

BTRFS: Copy-on-write

### ZFS

RAID-Z1: 2+ disk for storage and 1 for parity. Dynamic stripe width.

Integrity: use checksum

#### Write caching

ZFS Intent Log (ZIL) on SLOG: writes are sent to ZIL, then flushed to long-term storage.

SLOG device: SSD / flash.

#### Read caching

- Multiple layers
- ARC

### BTRFS

Blocks with active data are reallocated instead of overwritten.

- Allows snapshots: image of entire data, can be restored. (No extra overhead.)

Space efficient: all unchanged data is shared.

Clones: writable snapshots.

- Disk blocks managed in extents, less fragmentation.

- Changes accumulated in memory and written back. Superblock is modified to point
to the new checkpoint.

- Needs defragmentation.

- Good concurrency: traverse using read lock. If write lock is needed, COW the block.

- Multiple device support.

#### Trees

- Subvolumn: user-visible files and dirs
- Extent: tracks allocated extent items (free-space map)
- Checksum: One checksum item per allocated extent

Snapshot is just a new subvolume that shares data with other subvolumes.
