---
title: "CSC258 Review"
date: 2023-04-16
---

* TOC {:toc}

[//]: <> (lec02-transistor.md)
## Transistors

### Semiconductors

*Semiconductor*:
Sillicon, Germanium. stable at room temperature,
allowing a small current.

*Impurities*:
n-type: group 15 (Phosphrous), p-type: group 13 (Boron).

*Doping*:
adding impurities to semiconductors.

n-type semiconductor has extra electron, while p-type semiconductor has holes.

When bringing p-type and n-type together, the electrons will mix with the holes,
creating a *depletion layer* (diffusion), and corresponding electric field (drift).
These two currents reach equilibrium.

*Forward bias*: (the arrow represents direction of electron)
```
+ | p-type | n-type | -
       < diffusion
       drift >
       < bias
```

Narrows the depletion layer and increase diffusion rate, short circuit.

*Reverse bias*: the contrary of forward bias, open circuit.

### Transistors

*MOSFET*: Metal Oxide Semiconductor Field Effect Transistor

[//]: <> (lec08-alu.md)
## ALU

### ALU flags

- C: Carry
- Z: Zero
- N: Negative
- V: Overflow

### Multiplication

- Booth's Algorithm

If [i:i-1] = "01", the multiplicand is added at position i.

If [i:i-1] = "10", the multiplicand is subtracted from position i.

```python
def booth(a: Integer, b: Integer) -> Integer:
    assert len(a) == len(b)
    N = len(a) * 2
    a = a.extend(N)
    b = b.extend(N)
    print(a, b)
    cur = Integer(N)
    for i in range(N - 1, 0, -1):
        if b.content[i] == 0 and b.content[i - 1] == 1:
            nxt = a.sll(i)
        elif b.content[i] == 1 and b.content[i - 1] == 0:
            nxt = (-a).sll(i)
        else:
            continue
        print(f" {cur}\n+{nxt}\n={cur + nxt} ({i})\n")
        cur += nxt
    return cur
```

[//]: <> (lec08-memory.md)
## Memory

### Read

```
Address:
                |< -RC------------------------------------------- >|
                | Address Valid                                    |
                |< OHA >|       |                                  |
                |< -AA-------- >|                                  |< OHA >|
Data Out:               |       |                                  |       |
Prev Data Valid         |       | Data Valid                               | ...
```

- RC: Read Cycle Time, minimum time needed between two read cycles.
- AA: Address Access Time, time needed for address to be stable before read.
- OHA: Output Hold Time, time output data is held after change of address.

### Write

```
Address:
                |< -WC-------------------------------------------- >|
                | Address Valid                                     |
Read/nWrite:    |< SA >| < -WP----------------------------- >|< HA >|
0                      | 1                                   | 0
Data In:                          |< -SD------------------- >|< -HD---- >|
                                  | Data Valid                           |

```

- WC: Write Cycle Time.
- SA: Address Setup Time, time needed for address to be stable before enabling write.
- HA: Address Hold Time, time needed for address to be stable after enabling write.
- WP: Write Pulse Width
- SD: Data Setup Time (to Write End), time for data-in value to be setup at destination.
- HD: Data Hold Time (from Write End), time for data-in value should stay unchanged after write signal changes.

### General
- Address need time to setup
- Be conservative about timing

[//]: <> (lec09-endianess.md)
## Endianess

Big endian:
```
|X     |X+1   |X+2   |X+3   |
| Byte | Byte | Byte | Byte |
^ MSB                       ^ LSB
```

Little endian:
```
|X     |X+1   |X+2   |X+3   |
|31  24|23  16|15   8|7    0|
| Byte | Byte | Byte | Byte |
^ LSB                       ^ MSB
```

[//]: <> (lec09-memory_structure.md)
## Application Memory View

```
+-------------+
| Reserved    |
+-------------+
| .text       |
+-------------+
| .data       |
+-------------+
| Heap        |
+-------------+
| Unallocated |
+-------------+
| Stack       |
+-------------+
| OS          |
+-------------+
```

[//]: <> (lec09-mips_format.md)
## MIPS Instruction Types

### R-type

Machine code:
```
|31    26|25 21|20 16|15 11|10    6|5     0|
| 6      | 5   | 5   | 5   | 5     | 6     | =32
| opcode | rs  | rt  | rd  | shmat | funct |
```

### I-type

Machine code:
```
|31    26|25 21|20 16|15  0|
| 6      | 5   | 5   | 16  | =32
| opcode | rs  | rt  | IMM |
```

### J-Type

Machine code:
```
|31    26|25             0|
| 6      | 26             | =32
| opcode | pseudo-address |
```

Actual address:
```
|31     28|27             2| 1         0|
| 4       | 26             | 2          | =32
| next PC | pseudo-address | word align |
```

[//]: <> (lec09-mips_instruction.md)
## MIPS Instructions

### Arithmetic instructions

- I-type: `IMM` is sign extended.
- `div?`: `lo = $rs / $rt`, `hi = $rs % $rt`.
- `mult?`: `hi:lo = $s * $t`.
- `(add|sub)?u`: same as `(add|sub)?`, but does not trap on overflow.
- `(mult|div)u` behaves differently from `(mult|div)`.

### Logical instructions

- I-type: `IMM` is zero extended.

### Shift instructions

- `sll*` operations will always sign extend into a 64-bit register, then
truncates the value into 32 bits.

### Jump instructions

- `j`: according to slides, `pc = (pc & 0xF0000000) | (IMM << 2)`, which is
different from the specification.

- The range of `j` is 256 MBytes.

### Branch instructions

- The offset is `i = (label - (next PC)) >> 2`. This is different from the slides.

- The range `b*` is +/- 128 KBytes.

### Comparison instructions

Reference: [mips-isa](https://www.cs.cmu.edu/afs/cs/academic/class/15740-f97/public/doc/mips-isa.pdf)
